package com.Concurrent.Synchronized;

public class SynchronizedDemo {
    /**
     * 自旋锁： 线程状态及上下文切换消耗系统资源，当访问共享资源的时间短，频繁上下文切换不值得。jvm实现，使线程在没获得锁的时候，不被挂起，转而执行空循环，循环几次之后，如果还没能获得锁，则被挂起
     *
     * 阻塞锁：阻塞锁改变了线程的运行状态，让线程进入阻塞状态进行等待，当获得相应的信号（唤醒或者时间）时，才可以进入线程的准备就绪状态，转为就绪状态的所有线程，通过竞争，进入运行状态
     *
     * 重入锁:支持线程再次进入的锁,就跟我们有房间钥匙，可以多次进入房间类似
     *
     * 读写锁： 两把锁，读锁跟写锁，写写互斥、读写互斥、读读共享
     *
     * 互斥锁： 上厕所，进门之后就把门关了，不让其他人进来
     *
     * 悲观锁： 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁
     *
     * 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。
     *
     * 公平锁：大家都老老实实排队，对大家而言都很公平
     *
     * 非公平锁：一部分人排着队，但是新来的可能插队
     *
     * 偏向锁：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁
     *
     * 独占锁：独占锁模式下，每次只能有一个线程能持有锁
     *
     * 共享锁：允许多个线程同时获取锁，并发访问共享资源
     */
}
